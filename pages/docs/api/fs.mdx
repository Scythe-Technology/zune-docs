## File System

import { Callout } from 'nextra/components'

<Callout type="info" emoji="ℹ️">Page is being worked on.</Callout>

A built-in module that provides access to the file system.
### Functions
1. [readFile](#readfile)
2. [readDir](#readdir)
3. [writeFile](#writefile)
4. [writeDir](#writedir)
5. [removeFile](#removefile)
6. [removeDir](#removedir)
7. [metadata](#metadata)
8. [isFile](#isfile)
9. [isDir](#isdir)
10. [move](#move`)
11. [copy](#copy)
12. [symlink](#symlink)
13. [watch](#watch)
14. [openFile](#openfile)
15. [createFile](#createfile)

## Functions
#### readFile
```luau
fs.readFile(path: string, useBuffer: boolean?): (boolean, string | buffer | FileReadError)
```
##### Parameters
- `path: string` - The path to the file to read.
- `useBuffer: boolean` - If true, the function will return a `buffer` instead of a `string`.
  - Default: `false`
##### Returns
- `boolean` - If the operation was successful.
- `string` | `buffer` | [`FileReadError`](#filereaderror) - The content of the file or an error.

#### readDir
```luau
fs.readDir(path: string): (boolean, { string } | string)
```
##### Parameters
- `path: string` - The path to the directory to read.
##### Returns
- `boolean` - If the operation was successful.
- `{ string }` | `string` - The content of the directory or an error.

#### writeFile
```luau
fs.writeFile(path: string, contents: buffer | string): (boolean, FileWriteError?)
```
##### Parameters
- `path: string` - The path to the file to write.
- `contents: buffer | string` - The content to write to the file (This may be limited to the max luau `string`).
##### Returns
- `boolean` - If the operation was successful.
- [`FileWriteError?`](#filewriteerror) - An error if the operation failed.

#### writeDir
```luau
fs.writeDir(path: string, recursive: boolean?): (boolean, DirWriteError?)
```
##### Parameters
- `path: string` - The path to the directory to write.
- `recursive: boolean` - If true, the function will create the directory and all parent directories.
  - Default: `false`
##### Returns
- `boolean` - If the operation was successful.
- [`DirWriteError?`](#dirwriteerror) - An error if the operation failed.

#### removeFile
```luau
fs.removeFile(path: string): (boolean, FileRemoveError?)
```
##### Parameters
- `path: string` - The path to the file to remove.
##### Returns
- `boolean` - If the operation was successful.
- [`FileRemoveError?`](#fileremoveerror) - An error if the operation failed.

#### removeDir
```luau
fs.removeDir(path: string, recursive: boolean?): (boolean, DirRemoveError?)
```
##### Parameters
- `path: string` - The path to the directory to remove.
- `recursive: boolean` - If true, the function will remove the directory and all its contents.
  - Default: `false`
##### Returns
- `boolean` - If the operation was successful.
- [`DirRemoveError?`](#dirremoveerror) - An error if the operation failed.

#### metadata
```luau
fs.metadata(path: string): (boolean, Metadata? | MetadataError)
```
##### Parameters
- `path: string` - The path to the file or directory to get metadata from.
##### Returns
- `boolean` - If the operation was successful.
- [`Metadata?`](#metadata) | [`MetadataError`](#metadataerror)- The metadata of the file or directory, or error, or nil.

#### isFile
```luau
fs.isFile(path: string): boolean
```
##### Parameters
- `path: string` - The path to the file to check.
##### Returns
- `boolean` - If the path is a file.

#### isDir
```luau
fs.isDir(path: string): boolean
```
##### Parameters
- `path: string` - The path to the directory to check.
##### Returns
- `boolean` - If the path is a directory.

#### move
```luau
fs.move(from: string, to: string, overwrite: boolean?): (boolean, MoveError?)
```
##### Parameters
- `from: string` - The path to the file or directory to move.
- `to: string` - The path to move the file or directory to.
- `overwrite: boolean` - If true, the function will overwrite the file if it exists.
  - Default: `false`
##### Returns
- `boolean` - If the operation was successful.
- [`MoveError?`](#moverror) - An error if the operation failed.

#### copy
```luau
fs.copy(from: string, to: string, overwrite: boolean?): (boolean, CopyError?)
```
##### Parameters
- `from: string` - The path to the file or directory to copy.
- `to: string` - The path to copy the file or directory to.
- `overwrite: boolean` - If true, the function will overwrite the file if it exists.
  - Default: `false`
##### Returns
- `boolean` - If the operation was successful.
- [`CopyError?`](#copyerror) - An error if the operation failed.

#### symlink
```luau
fs.symlink(from: string, to: string): (boolean, SymlinkError?)
```
<Callout type="error" emoji="️🚫">Windows: Not Supported</Callout>
##### Parameters
- `from: string` - The path to the file or directory to link.
- `to: string` - The path to link the file or directory to.
##### Returns
- `boolean` - If the operation was successful.
- [`SymlinkError?`](#symlinkerror) - An error if the operation failed.
  - Windows: Always returns `"NotSupported"`.

#### watch
```luau
fs.watch(path: string, callback: (path: string, events: {"created" | "modified" | "moved" | "renamed" | "deleted" | "metadata"}) -> ()): FileWatcher
```
<Callout type="warning" emoji="️⚠️">Can Error</Callout>
<Callout type="info" emoji="ℹ️">Experimental</Callout>

Watches a directory for changes.

*Does not watch subdirectories.*
*Windows: Can watch changes in first child subdirectories.*
##### Parameters
- `path: string` - The path to the directory to watch.
- `callback: (path: string, events: {"created" | "modified" | "moved" | "renamed" | "deleted" | "metadata"}) -> ()` - The function to call when a change is detected.
##### Returns
- [`FileWatcher`](#filewatcher) - The file watcher.

#### openFile
```luau
fs.openFile(path: string, opts: OpenFileOptions?): (boolean, FileHandle | FileReadError);
```
##### Parameters
- `path: string` - The path to the file to open.
- `opts: `[`OpenFileOptions`](#openfileoptions) - The options for opening the file.
##### Returns
- `boolean` - If the operation was successful.
- [`FileHandle`](#filehandle) | [`FileReadError`](#filereaderror) - The file handle or an error.

#### createFile
```luau
fs.createFile(path: string, opts: CreateFileOptions?): (boolean, FileHandle | FileReadError);
```
##### Parameters
- `path: string` - The path to the file to create.
- `opts: `[`CreateFileOptions`](#createfileoptions) - The options for creating the file.
##### Returns
- `boolean` - If the operation was successful.
- [`FileHandle`](#filehandle) | [`FileReadError`](#filereaderror) - The file handle or an error.

## Types
#### IOError
```luau copy
type IOError = "AccessDenied"
| "FileNotFound"
| "UnknownError"
```

#### DiskError
```luau copy
type DiskError = "DiskQuotaExceeded"
```

#### FileError
```luau copy
type FileError = "Aborted"
```

#### DeviceError
```luau copy
type DeviceError = "Busy"
```

#### ReadError
```luau copy
type ReadError = "OutOfMemory"
```

#### NetworkError
```luau copy
type NetworkError = "NetworkNotFound"
```

#### EncodingError
```luau copy
type EncodingError = "InvalidUtf-8"
| "InvalidWtf-8"
```

#### FileReadError
```luau copy
export type FileReadError = IOError
| FileError
| DeviceError
| ReadError
| "NotFile"
| "NotOpenForReading"
| "FailedToCreateBuffer"
```

#### FileWriteError
```luau copy
export type FileWriteError = IOError
| DiskError
| FileError
| DeviceError
| "TooBig"
| "OutOfSpace"
| "Locked"
| "NotOpenForWriting"
| "FailedToWriteBuffer"
```

#### DirWriteError
```luau copy
export type DirWriteError = IOError
| DiskError
| NetworkError
| EncodingError
| "BadName"
| "TooLong"
| "SymbolicLinkLoop"
| "PathAlreadyExists"
| "SymbolicLinkQuotaExceeded"
```

#### FileRemoveError
```luau copy
export type FileRemoveError = IOError
| DeviceError
| "NotFile"
```

#### DirRemoveError
```luau copy
export type DirRemoveError = IOError
| DeviceError
| "NotDirectory"
| "DirNotEmpty"
```

#### MetadataError
```luau copy
export type MetadataError = IOError
| DeviceError
```

#### MetadataKind
```luau copy
export type MetadataKind = "file"
	| "dir"
	| "symlink"
	| "door"
	| "character_device"
	| "unix_domain_socket"
	| "block_device"
	| "event_port"
	| "named_pipe"
	| "whiteout"
	| "unknown"
```

#### Metadata
```luau copy
export type Metadata = {
	kind : MetadataKind,
	symlink : boolean,
	createdAt : number,
	modifiedAt : number,
	accessedAt : number,
	size : number,
	permissions : {
		readOnly : boolean,
	},
}
```

#### MoveError
```luau copy
export type MoveError = IOError
| DeviceError
| DiskError
| NetworkError
| EncodingError
| "NotFile"
| "NotDirectory"
| "PathAlreadyExists"
| "DirNotEmpty"
| "SymbolicLinkLoop"
| "SharingViolation"
| "TooLong"
| "AntivirusInterference"
| "BadName"
```

#### CopyError
```luau copy
export type CopyError = IOError
| DeviceError
```

#### SymlinkError
```luau copy
export type SymlinkError = IOError
| DiskError
| EncodingError
| NetworkError
| "TooLong"
| "PathAlreadyExists"
| "BadName"
| "NotDirectory"
| "OutOfSpace"
| "SymbolicLinkLoop"
| "NotDirectory"
| "NotFile"
| "NotSupported"
```

#### FileWatcher
```luau copy
export type FileWatcher = {
	--[[
		Stops the watcher.
	]]
	stop : (self: FileWatcher) -> (),
}
```

#### FileHandle
```luau copy

export type FileHandle = {
	--[[
		Reads the contents of a file.

		*Optional: The amount of bytes to read, if nil, reads the whole till EOF or Luau limit.*

		@param amount The amount of bytes to read.
	]]
	read :
		& ((self: FileHandle, amount: number?, useBuffer: false?) -> string)
		& ((self: FileHandle, amount: number?, useBuffer: true) -> buffer),


	--[[
		Writes to a file.

		@param contents The contents to write to the file.
	]]
	write : (self: FileHandle, contents: buffer | string) -> (),

	--[[
		Appends to a file.
		
		@param contents The contents to append to the file.
	]]
	append : (self: FileHandle, contents: buffer | string) -> (),

	--[[
		Returns the size of the file. Based on current state of the file object.
	]]
	getSize : (self: FileHandle) -> number,

	--[[
		Returns the current position of the file.
	]]
	getSeekPosition : (self: FileHandle) -> number,

	--[[
		Seeks to a position in the file relative to the end.

		*Optional: The amount of bytes to seek, if nil, seeks to the end*

		@param amount The amount of bytes to seek.
	]]
	seekFromEnd : (self: FileHandle, amount: number?) -> (),

	--[[
		Seeks to a position in the file absolute to the start.

		*Optional: The amount of bytes to seek, if nil, seeks to the start, 0*

		@param amount The amount of bytes to seek.
	]]
	seekTo : (self: FileHandle, amount: number?) -> (),

	--[[
		Seeks to a position in the file relative to the current position.

		*Optional: The amount of bytes to seek, if nil, seeks to the next position, 1*

		*If `0` is provided, seek will not move.*

		@param amount The amount of bytes to seek.
	]]
	seekBy : (self: FileHandle, amount: number?) -> (),

	--[[
		Locks the file.

		*Optional: The mode to lock the file, if nil, locks the file in exclusive mode.*

		@param lockMode The mode to lock the file.
	]]
	lock : (self: FileHandle, lockMode: ("shared" | "exclusive" | "none")?) -> boolean,

	--[[
		Unlocks the file.
	]]
	unlock : (self: FileHandle) -> (),

	--[[
		Flushes the file. Writes the contents to the disk.

		Does not yield, **blocks** process.
	]]
	sync : (self: FileHandle) -> (),

	--[[
		Closes the file. (Will flush the file)
	]]
	close : (self: FileHandle) -> (),
}
```

#### OpenFileOptions
```luau copy
type OpenFileOptions = {
	--[[
		The mode to open the file in.

		Available modes: `r`, `w`

		*Default: `rw`*
	]]
	mode : string?,
}
```

#### CreateFileOptions
```luau copy
type CreateFileOptions = {
	--[[
		Whether to create the file in exclusive mode.

		*Default: false*
	]]
	exclusive : boolean?,
}
```
